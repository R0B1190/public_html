<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Glass</title>
    <meta name="generator" content="thesitewizard.com's Layout Wizard 4.0.0">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Meta tags for a better mobile experience, especially on iOS for "Add to Home Screen" -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="stylesheet" type="text/css" media="all" href="styles.css">
    <link rel="stylesheet" type="text/css" href="tswnavbar.css" />
    <link rel="stylesheet" type="text/css" href="nav-styles.css" />
    <style>
        body {
            /* Animated gradient background */
            background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);
            background-size: 400% 400%;
            animation: animateGradient 15s ease infinite;
        }

        /* Style for the active page link on gameSkin.html */
        #tswcssbuttons a[href="gameSkin.html"] {
            background-color: #a25b09; /* A darker shade of the page background */
            color: white;
        }

        #tswcssbuttons ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }

        #tswcssbuttons li a {
            display: block;
            padding: 12px;
            margin-bottom: 8px;
            text-decoration: none;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
            /* Glass Style */
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            background: radial-gradient(ellipse at 30% 25%, white 0%, rgba(255, 255, 255, 0) 50%), radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.1) 80%);
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7), inset 0 -4px 5px rgba(0, 0, 0, 0.2), 2px 2px 5px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            transition: all 0.15s ease-out;
        }

        #tswcssbuttons li a:hover {
            background: radial-gradient(ellipse at 30% 25%, white 0%, rgba(255, 255, 255, 0) 50%), radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.2) 80%);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.8), inset 0 -4px 5px rgba(0, 0, 0, 0.2), 3px 3px 7px rgba(0, 0, 0, 0.4);
        }

        #tswcssbuttons li a:active {
            transform: translate(1px, 1px);
            box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.5);
        }

        /* --- Game Styles --- */
        #game-container {
            width: 100%;
            max-width: 800px;
            aspect-ratio: 16 / 9;
            position: relative; /* For positioning children like the start menu and fullscreen button */
            margin: 20px auto; /* Center the container */
            border-radius: 15px; /* Rounded corners */
            overflow: hidden; /* Keeps player glow inside */
            transition: all 0.4s ease-in-out;
    /* New Glass Border Style */
    background: rgba(0, 0, 0, 0.15); /* A subtle dark tint for the glass */
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.3), /* Inner highlight */
                0 5px 15px rgba(0, 0, 0, 0.5); /* Outer shadow */
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px); /* Safari support */
        }

        @keyframes animateGradient {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        /* When fullscreen, the container should fill the screen */
        #game-container:fullscreen {
            width: 100%;
            height: 100%;
            border-radius: 0;
            background: #000; /* Black background for letterboxing */
            border: none; /* Remove the standard border */
        }

        /* Add the animated gradient back INSIDE the container when in standalone mode, so the glass effect has a background. */
        body.standalone-mode #game-container::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1; /* Place it behind all of the container's content */
            /* The animated gradient from the body */
            background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);
            background-size: 400% 400%;
            animation: animateGradient 15s ease infinite;
        }
        
        /* In fullscreen, the viewport gets the gradient background, while the container is black for letterboxing */
        #game-container:fullscreen #game-viewport {
            /* The animated gradient from the body */
            background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);
            background-size: 400% 400%;
            animation: animateGradient 15s ease infinite;
        }

        #game-viewport {
            width: 800px;
            height: 450px; /* 16:9 aspect ratio with 800px width */
            /* The background is now on the body, so this is transparent */
            background-color: transparent;
            position: absolute; /* Take out of flow to allow parent to scale correctly */
            top: 50%;
            left: 50%;
            overflow: hidden; /* Keeps player and obstacles inside */
            transform-origin: center; /* Scale/transform from the center */
            transition: transform 0.4s ease-in-out, border-radius 0.4s ease-in-out;
            border-radius: 15px;
        }

        #player-circle {
            width: 50px;
            height: 50px;
            /* Layered gradients for a sharp, shiny glint and a subtle body highlight */
            background:
                /* 1. Sharp, top-left glint */
                radial-gradient(ellipse at 30% 25%, white 0%, rgba(255, 255, 255, 0) 50%),
                /* 2. Base glass transparency */
                radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.1) 80%);
            border: 1px solid rgba(255, 255, 255, 0.4); /* A crisp edge for the glass */
            border-radius: 50%;
            position: absolute; /* Position relative to the container */
            /* Cleaned up shadows for a more defined 3D look */
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, 0.7), /* Clean inner top highlight */
                inset 0 -4px 5px rgba(0, 0, 0, 0.25),   /* Deeper inner bottom shadow */
                5px 5px 8px rgba(0, 0, 0, 0.4);      /* Original drop shadow */

            /* This makes the background seen through the ball blurry, like frosted glass. */
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px); /* Safari support */
            transition: height 0.1s ease-in-out; /* Smooth squish on height only */
            will-change: left, top, backdrop-filter; /* Performance optimization hint for movement */
            /* Start in the middle */
            top: calc(50% - 25px);
            left: calc(50% - 25px);
            display: none; /* Hidden until game starts */
        }

        #obstacle-triangle {
            width: 50px;
            height: 50px;
            position: absolute;
            bottom: 0;
            left: 300px;
            display: none; /* Hidden until game starts */
            
            /* Create triangle shape */
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
            -webkit-clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
            
            /* The outline and shadow are applied to the clipped container. */
            filter: drop-shadow(0 0 2px white) drop-shadow(3px 3px 4px rgba(0, 0, 0, 0.5));
            will-change: left, filter; /* Performance optimization hint */
            
            /* This ensures the ::before pseudo-element is clipped correctly. */
            overflow: hidden;
        }

        #obstacle-triangle::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            /* The glass styling is now on the pseudo-element. */
            background:
                radial-gradient(ellipse at 50% 20%, white 0%, rgba(255, 255, 255, 0) 60%),
                radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.05) 80%);
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
        }

        #obstacle-rectangle {
            width: 100px;
            height: 415px; /* Adjusted to account for player border, allowing squished player to pass under */
            position: absolute;
            display: none; /* Hidden until game starts */
            will-change: left; /* Performance optimization hint for movement */

            /* Glass Style (adapted from other elements) */
            background: radial-gradient(ellipse at 30% 10%, white 0%, rgba(255, 255, 255, 0) 50%), radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 80%);
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.6), inset 0 -5px 5px rgba(0, 0, 0, 0.2), 5px 0px 10px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
        }

        #start-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(200, 200, 200, 0.7); /* Lighter overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10; /* Make sure it's on top */
        }

        #start-button {
            padding: 15px 30px;
            font-size: 2em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 10px;
            /* Glass Style */
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            background: radial-gradient(ellipse at 30% 25%, white 0%, rgba(255, 255, 255, 0) 50%), radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.1) 80%);
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7), inset 0 -4px 5px rgba(0, 0, 0, 0.2), 2px 2px 5px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            transition: all 0.15s ease-out;
        }

        #start-button:hover {
            background: radial-gradient(ellipse at 30% 25%, white 0%, rgba(255, 255, 255, 0) 50%), radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.2) 80%);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.8), inset 0 -4px 5px rgba(0, 0, 0, 0.2), 3px 3px 7px rgba(0, 0, 0, 0.4);
        }

        #start-button:active {
            transform: translate(1px, 1px);
            box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.5);
        }

        #score {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 1.5em;
            font-weight: bold;
            z-index: 5;
            display: none; /* Hidden until game starts */
            /* Glass text effect for readability */
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        /* Glass effect for page text */
        #tswcontproper h1,
        #tswcontproper h2,
        #tswcontproper p {
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        #fullscreen-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            font-size: 1.5em;
            border-radius: 8px;
            cursor: pointer;
            z-index: 15;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            line-height: 1;
            user-select: none;
            /* Glass Style */
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            background: radial-gradient(ellipse at 30% 25%, white 0%, rgba(255, 255, 255, 0) 50%), radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.1) 80%);
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7), inset 0 -4px 5px rgba(0, 0, 0, 0.2), 2px 2px 5px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            transition: all 0.15s ease-out;
        }

        #fullscreen-btn:hover {
            background: radial-gradient(ellipse at 30% 25%, white 0%, rgba(255, 255, 255, 0) 50%), radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.2) 80%);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.8), inset 0 -4px 5px rgba(0, 0, 0, 0.2), 3px 3px 7px rgba(0, 0, 0, 0.4);
        }

        #fullscreen-btn:active {
            transform: translate(1px, 1px);
            box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.5);
        }


        /* --- Mobile Controls --- */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            z-index: 20;
            display: none; /* Hidden until game starts, set to 'flex' by JS */
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none; /* Let clicks pass through the container */
        }

        .control-cluster {
            display: flex;
            gap: 25px;
            pointer-events: all; /* But not through the clusters */
        }

        #action-controls {
            flex-direction: column;
            gap: 10px;
        }

        .control-btn {
            width: 75px;
            height: 75px;
            font-size: 2.5em;
            font-weight: bold;
            border-radius: 50%; /* Circular buttons */
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            /* Glass Style */
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            background: radial-gradient(ellipse at 30% 25%, white 0%, rgba(255, 255, 255, 0) 50%), radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.1) 80%);
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7), inset 0 -4px 5px rgba(0, 0, 0, 0.2), 2px 2px 5px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            transition: all 0.15s ease-out;
        }

        .control-btn:active {
            transform: translate(1px, 1px);
            box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.5);
        }

        .skin-button {
            display: inline-block;
            padding: 10px 20px;
            margin-top: 5px;
            margin-right: 10px; /* Add space between buttons */
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            text-align: center;
            text-decoration: none;
            border-radius: 8px;
            /* Glass Style */
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            background: radial-gradient(ellipse at 30% 25%, white 0%, rgba(255, 255, 255, 0) 50%), radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.1) 80%);
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7), inset 0 -4px 5px rgba(0, 0, 0, 0.2), 2px 2px 5px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            transition: all 0.15s ease-out;
        }
        .skin-button:hover {
            background: radial-gradient(ellipse at 30% 25%, white 0%, rgba(255, 255, 255, 0) 50%), radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.2) 80%);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.8), inset 0 -4px 5px rgba(0, 0, 0, 0.2), 3px 3px 7px rgba(0, 0, 0, 0.4);
        }
        .skin-button:active {
            transform: translate(1px, 1px);
            box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.5);
        }

        /* --- iOS Standalone (Home Screen App) Mode --- */
        body.standalone-mode #game-container #game-viewport,
        #game-container:fullscreen #game-viewport {
            border-radius: 0;
        }

        /* --- iOS Standalone (Home Screen App) Mode --- */
        /* When running as a home screen app, hide all non-game content */
        body.standalone-mode #tswheader,
        body.standalone-mode #tswsidecol,
        body.standalone-mode #tswfooter,
        body.standalone-mode #tswcontproper > h1,
        body.standalone-mode #tswcontproper > p,
        body.standalone-mode #tswcontproper > h2,
        body.standalone-mode #tswcontproper > a.skin-button {
            display: none;
        }

        /* Make the game container and its parents fill the entire screen */
        body.standalone-mode,
        body.standalone-mode #tswcontainer,
        body.standalone-mode #tswcontent,
        body.standalone-mode #tswcontproper {
            /* Override default layout styles for true fullscreen */
            width: 100%;
            float: none;
            height: 100vh; /* Use viewport height */
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrollbars */
        }

        /* Force the game container to fill its new full-screen parent */
        body.standalone-mode #game-container {
            height: 100%;
            max-width: none;
            margin: 0;
            border-radius: 0;
            aspect-ratio: auto; /* Override aspect-ratio to allow full height */
        }

        /* --- Shatter Effect --- */
        #shatter-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through */
            overflow: hidden;
        }

        .shard {
            position: absolute;
            /* custom properties will be set by JS */
            animation: shatter 1.5s forwards cubic-bezier(0.1, 0.8, 0.7, 1);
            /* This is the key: it makes the clip-path (set by JS) affect the pseudo-element */
            overflow: hidden;
        }

        .shard::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            /* Match the player's glass style for consistency */
            background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.5) 0%, rgba(255, 255, 255, 0.2) 90%);
            backdrop-filter: blur(1px);
            -webkit-backdrop-filter: blur(1px);
        }

        @keyframes shatter {
            0% {
                transform: translate(0, 0) rotate(0deg);
                opacity: 1;
            }
            100% {
                /* These values are set dynamically by JS for each shard */
                transform: translate(var(--translateX), var(--translateY)) rotate(var(--rotateZ));
                opacity: 0;
            }
        }
    </style>
</head>

<body>

    <div id="tswcontainer">
        <div id="tswheader">
            <!-- start of header section: insert your logo, etc, here -->

            <p>
              <!--  Placeholder content for your header section. Replace it with your website's logo or name or page title
                or whatever. -->
            </p>
            <p>&nbsp;</p>

            <!-- end of header section: insert your logo, etc, above this line -->
        </div>

        <div id="tswcontent">
            <div id="tswcontproper">
                <!-- start of content column: insert your content here -->

                <h1>Game</h1>
                <p>Use A/D or Left/Right arrow keys to move. Use W or the Up arrow key to jump. Use S or the Down arrow key to squish.</p>

                <div id="game-container">
                    <button id="fullscreen-btn" title="Toggle Fullscreen">&#10546;</button>
                    <div id="start-menu">
                        <button id="start-button">Start Game</button>
                    </div>
                    <div id="game-viewport">
                        <div id="score">Score: 0</div>
                        <div id="shatter-container"></div>
                        <div id="player-circle"></div>
                        <div id="obstacle-triangle"></div>
                        <div id="obstacle-rectangle"></div>
                        <div id="mobile-controls">
                            <div class="control-cluster" id="movement-controls">
                                <button id="btn-left" class="control-btn">◀</button>
                                <button id="btn-right" class="control-btn">▶</button>
                            </div>
                            <div class="control-cluster" id="action-controls">
                                <button id="btn-up" class="control-btn">▲</button>
                                <button id="btn-down" class="control-btn">▼</button>
                            </div>
                        </div>
                    </div>
                </div>

                <h2>Skins</h2>
                <a href="projects.html" class="skin-button">Default</a>
                <a href="gameSkinClassic.html" class="skin-button">Classic</a>
                <a href="gameSkinNeon.html" class="skin-button">Neon</a>
                <a href="gameSkin.html" class="skin-button">Glass</a>

                <!-- end of content column: put your content above this line -->
            </div>
        </div>

        <div id="tswsidecol">
            <div id="tswsideproper">
                <!-- start of side column: insert your navigation menu, etc, here -->

                <div id="tswcssbuttons">
                    <ul>
                        <li><a href="index.html">Home</a></li>
                        <li><a href="aboutme.html">Page 2</a></li>
                        <li><a href="projects.html">Game</a></li>
                        <li><a href="word_fold/game.html">Word Fold</a></li>
                        <li><a href = "clickgame-broken/index.html">Gompie's Grass Game</a></li>
                    </ul>
                </div>


                <!-- end of side column: put your navigation menu, etc, above this line -->
            </div>
        </div>
        <div style="clear: both;"></div>

        <div id="tswfooter">
            <!-- start of footer section: insert your copyright notice, etc, here -->

            <p>
                <!-- Placeholder content for the footer: please replace these words with your real content. -->
            </p>

            <!-- end of footer section: insert your copyright notice, etc, above this line -->
        </div>

    </div>

    <script>
        const player = document.getElementById('player-circle');
        const container = document.getElementById('game-container');
        const gameViewport = document.getElementById('game-viewport');
        const startMenu = document.getElementById('start-menu');
        const startButton = document.getElementById('start-button');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const shatterContainer = document.getElementById('shatter-container');
        const obstacle = document.getElementById('obstacle-triangle');
        const obstacleRectElement = document.getElementById('obstacle-rectangle');
        const scoreDisplay = document.getElementById('score');
        const mobileControls = document.getElementById('mobile-controls');
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnUp = document.getElementById('btn-up');
        const btnDown = document.getElementById('btn-down');
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const isStandalone = window.navigator.standalone === true; // Check for iOS Home Screen app mode

        // If running as a Home Screen app on iOS, add a class to the body to trigger fullscreen styles.
        if (isStandalone) {
            document.body.classList.add('standalone-mode');
        }
        
        // Game world constants
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 450; // 16:9 aspect ratio
        const BORDER_WIDTH = 1;
        
        // Player state
        let x;
        let y;
        let vy = 0; // Vertical velocity
        const moveSpeed = 5;
        const gravity = 0.5;
        const jumpStrength = 12;
        let isOnGround = false;
        let isSquished = false;

        // Game state
        let score = 0;
        let scoreInterval;
        let animationFrameId;

        // Obstacle state
        let obstacleX;
        let obstacleSpeed;
        let obstacleDirection = 1; // 1 for right, -1 for left

        // New obstacle state
        let rectObstacleX, rectObstacleY;
        const rectObstacleSpeed = 2; // Same speed as the triangle
        let rectObstacleDirection = -1; // Start moving left


        // Key state tracking for movement
        const keysPressed = {};

        document.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            keysPressed[key] = true;
        });

        document.addEventListener('keyup', (event) => {
            keysPressed[event.key.toLowerCase()] = false;
        });

        // Handle page visibility to prevent score from increasing in the background
        document.addEventListener('visibilitychange', () => {
            const isGameActive = startMenu.style.display === 'none';

            if (!isGameActive) {
                return; // Game is not running, do nothing.
            }

            if (document.hidden) {
                // Tab is hidden, pause the game logic and score.
                cancelAnimationFrame(animationFrameId);
                clearInterval(scoreInterval);
            } else {
                // Tab is visible again, resume the game.
                // Restart the score interval.
                scoreInterval = setInterval(() => {
                    score++;
                    scoreDisplay.textContent = `Score: ${score}`;
                    obstacleSpeed += 0.1; // Increase triangle speed every second
                }, 2000); // Update score every 2 seconds

                // Resume the game loop.
                gameLoop();
            }
        });

        function triggerShatterEffect(playerX, playerY) {
            // Clear any old shards
            shatterContainer.innerHTML = '';

            const SHARD_COUNT = 25; // More shards for a better effect
            const playerCenter_X = playerX + player.offsetWidth / 2;
            const playerCenter_Y = playerY + player.offsetHeight / 2;

            for (let i = 0; i < SHARD_COUNT; i++) {
                const shard = document.createElement('div');
                shard.className = 'shard';

                // Set shard initial position to the player's center
                shard.style.left = `${playerCenter_X}px`;
                shard.style.top = `${playerCenter_Y}px`;
                
                // Randomize shard size
                const size = 8 + Math.random() * 20; // More varied sizes
                shard.style.width = `${size}px`;
                shard.style.height = `${size}px`;

                // Use clip-path to create a random triangular shard shape
                const p1 = { x: 50 + (Math.random() - 0.5) * 50, y: (Math.random()) * 50 };
                const p2 = { x: (Math.random()) * 50, y: 50 + (Math.random()) * 50 };
                const p3 = { x: 50 + (Math.random()) * 50, y: 50 + (Math.random()) * 50 };
                shard.style.clipPath = `polygon(${p1.x}% ${p1.y}%, ${p2.x}% ${p2.y}%, ${p3.x}% ${p3.y}%)`;

                // Calculate a random trajectory
                const angle = Math.random() * Math.PI * 2;
                const distance = 90 + Math.random() * 100; // Fly a bit further
                // End position with a downward arc to simulate gravity
                const endX = Math.cos(angle) * distance;
                const endY = Math.sin(angle) * distance + (distance * 0.75); // More gravity effect
                const endRotation = (Math.random() - 0.5) * 1080; // Spin more

                // Set CSS custom properties for the animation
                shard.style.setProperty('--translateX', `${endX}px`);
                shard.style.setProperty('--translateY', `${endY}px`);
                shard.style.setProperty('--rotateZ', `${endRotation}deg`);

                shatterContainer.appendChild(shard);
            }
        }

        function endGame() {
            clearInterval(scoreInterval);
            cancelAnimationFrame(animationFrameId);
            if (isTouchDevice) mobileControls.style.display = 'none'; // Hide controls immediately

            // Hide the player and trigger the shatter effect
            player.style.display = 'none';
            triggerShatterEffect(x, y);

            // Show the "Play Again" menu after the animation finishes
            setTimeout(() => {
                startMenu.style.display = 'flex';
                startButton.textContent = 'Play Again';
            }, 1500); // Should match the animation duration
        }

        function checkPreciseCollision(currentObstacleX, squished) {
            // --- Player Circle Properties ---
            const playerWidth = player.offsetWidth;
            const playerHeight = player.offsetHeight;
            let playerRadius, playerCenterX, playerCenterY;

            if (squished) {
                // Approximate squished ellipse with a smaller circle for collision
                playerRadius = playerHeight / 2; // e.g., 12.5
                playerCenterX = x + playerWidth / 2;
                playerCenterY = y + playerHeight / 2;
            } else {
                // Normal circle
                playerRadius = playerWidth / 2; // e.g., 25
                playerCenterX = x + playerRadius;
                playerCenterY = y + playerRadius;
            }

            const circle = { x: playerCenterX, y: playerCenterY, r: playerRadius };

            // --- Obstacle Triangle Properties ---
            // We get these from the obstacle's known position and CSS dimensions
            const obstacleX = currentObstacleX;
            const obstacleY = obstacle.offsetTop;
            const obstacleWidth = obstacle.offsetWidth;
            const obstacleHeight = obstacle.offsetHeight; // This is 50

            // Define the triangle's vertices based on its position
            const v1 = { x: obstacleX + obstacleWidth / 2, y: obstacleY }; // Top vertex
            const v2 = { x: obstacleX, y: obstacleY + obstacleHeight }; // Bottom-left
            const v3 = { x: obstacleX + obstacleWidth, y: obstacleY + obstacleHeight }; // Bottom-right

            // --- Collision Detection Logic ---

            // Helper to calculate squared distance (faster than using Math.sqrt)
            function distanceSquared(p1, p2) {
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                return dx * dx + dy * dy;
            }

            // Helper to find the closest point on a line segment to the circle's center
            function closestPointOnSegment(p, a, b) {
                const ap = { x: p.x - a.x, y: p.y - a.y };
                const ab = { x: b.x - a.x, y: b.y - a.y };
                const ab2 = ab.x * ab.x + ab.y * ab.y;
                const ap_dot_ab = ap.x * ab.x + ap.y * ab.y;
                const t = Math.max(0, Math.min(1, ap_dot_ab / ab2)); // Clamp to segment
                return { x: a.x + ab.x * t, y: a.y + ab.y * t };
            }

            // 1. Check distance from circle center to each edge of the triangle
            const edges = [[v1, v2], [v2, v3], [v3, v1]];
            for (const edge of edges) {
                const closestPoint = closestPointOnSegment(circle, edge[0], edge[1]);
                if (distanceSquared(circle, closestPoint) < circle.r * circle.r) {
                    return true; // Collision with an edge
                }
            }

            // 2. Check if the circle's center is inside the triangle (for containment cases)
            const d1 = (circle.x - v2.x) * (v1.y - v2.y) - (v1.x - v2.x) * (circle.y - v2.y);
            const d2 = (circle.x - v3.x) * (v2.y - v3.y) - (v2.x - v3.x) * (circle.y - v3.y);
            const d3 = (circle.x - v1.x) * (v3.y - v1.y) - (v3.x - v1.x) * (circle.y - v1.y);
            const has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0);
            const has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);
            return !(has_neg && has_pos);
        }

        function checkRectangleCollision(rectX, rectY, squished) {
            // --- Player Circle Properties (same as in triangle collision) ---
            const playerWidth = player.offsetWidth;
            const playerHeight = player.offsetHeight;
            let playerRadius, playerCenterX, playerCenterY;

            if (squished) {
                playerRadius = playerHeight / 2;
                playerCenterX = x + playerWidth / 2;
                playerCenterY = y + playerHeight / 2;
            } else {
                playerRadius = playerWidth / 2;
                playerCenterX = x + playerRadius;
                playerCenterY = y + playerRadius;
            }

            // --- Rectangle Obstacle Properties ---
            const rectWidth = obstacleRectElement.offsetWidth;
            const rectHeight = obstacleRectElement.offsetHeight;

            // --- Circle-Rectangle Collision Logic ---
            // Find the closest point on the rectangle to the circle's center
            const closestX = Math.max(rectX, Math.min(playerCenterX, rectX + rectWidth));
            const closestY = Math.max(rectY, Math.min(playerCenterY, rectY + rectHeight));

            // Calculate the squared distance between the circle's center and this closest point
            const distanceX = playerCenterX - closestX;
            const distanceY = playerCenterY - closestY;
            return (distanceX * distanceX) + (distanceY * distanceY) < (playerRadius * playerRadius);
        }

        function gameLoop() {
            // --- Squish Logic ---
            const wantsToSquish = keysPressed['s'] || keysPressed['arrowdown'];
            if (wantsToSquish && !isSquished && isOnGround) {
                isSquished = true;
                player.style.height = '25px';
                y += 25; // Move top down to keep bottom in place
            } else if (!wantsToSquish && isSquished) {
                // Only unsquish if there's enough space above
                // (y is the top of the player, 0 is the ceiling)
                if (y >= 25) {
                    isSquished = false;
                    player.style.height = '50px';
                    y -= 25; // Move top up to keep bottom in place
                }
            }

            // Jump check - moved here for input buffering
            if ((keysPressed['w'] || keysPressed['arrowup']) && isOnGround) {
                vy = -jumpStrength;
                isOnGround = false;

                // Automatically un-squish when jumping
                if (isSquished) {
                    isSquished = false;
                    player.style.height = '50px';
                    y -= 25; // Adjust position to grow upwards
                }
            }

            // Horizontal movement
            let dx = 0;
            if (keysPressed['a'] || keysPressed['arrowleft']) dx -= 1;
            if (keysPressed['d'] || keysPressed['arrowright']) dx += 1;

            x += dx * moveSpeed;

            // Apply gravity
            vy += gravity;
            y += vy;

            // Enforce container boundaries
            const minX = BORDER_WIDTH;
            const maxX = GAME_WIDTH - player.offsetWidth - BORDER_WIDTH;
            const minY = BORDER_WIDTH;
            const maxY = GAME_HEIGHT - player.offsetHeight - BORDER_WIDTH;

            // Horizontal boundaries
            x = Math.max(minX, Math.min(maxX, x));

            // Vertical boundaries (ground check)
            if (y >= maxY) {
                y = maxY;
                vy = 0;
                isOnGround = true;
            } else {
                isOnGround = false;
            }

            // Vertical boundaries (ceiling check)
            if (y < minY) {
                y = minY;
                vy = 0; // Stop upward movement if it hits the ceiling
            }

            // Update the player's position on the screen
            player.style.left = `${x}px`;
            player.style.top = `${y}px`;

            // --- Obstacle Movement (respecting borders) ---
            obstacleX += obstacleSpeed * obstacleDirection;
            const obstacleMaxX = GAME_WIDTH - obstacle.offsetWidth - BORDER_WIDTH;
            if (obstacleX <= BORDER_WIDTH) {
                obstacleX = BORDER_WIDTH;
                obstacleDirection = 1; // Move right
            } else if (obstacleX >= obstacleMaxX) {
                obstacleX = obstacleMaxX;
                obstacleDirection = -1; // Move left
            }
            obstacle.style.left = `${obstacleX}px`;

            // --- Rectangle Obstacle Movement (respecting borders) ---
            rectObstacleX += rectObstacleSpeed * rectObstacleDirection;
            const rectObstacleMaxX = GAME_WIDTH - obstacleRectElement.offsetWidth - BORDER_WIDTH;
            if (rectObstacleX <= BORDER_WIDTH) {
                rectObstacleX = BORDER_WIDTH;
                rectObstacleDirection = 1; // Move right
            } else if (rectObstacleX >= rectObstacleMaxX) {
                rectObstacleX = rectObstacleMaxX;
                rectObstacleDirection = -1; // Move left
            }
            obstacleRectElement.style.left = `${rectObstacleX}px`;
            obstacleRectElement.style.top = `${rectObstacleY}px`;

            // --- Collision Checks ---
            if (checkPreciseCollision(obstacleX, isSquished)) {
                endGame();
                return; // Stop the game loop
            }
            if (checkRectangleCollision(rectObstacleX, rectObstacleY, isSquished)) {
                endGame();
                return; // Stop the game loop
            }

            // Continue the loop
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Start the game when the button is clicked
        startButton.addEventListener('click', () => {
            shatterContainer.innerHTML = ''; // Clear any leftover shards from a previous game
            startMenu.style.display = 'none';
            player.style.display = 'block';
            obstacle.style.display = 'block';
            obstacleRectElement.style.display = 'block';
            scoreDisplay.style.display = 'block';
            if (isTouchDevice) mobileControls.style.display = 'flex';
            startButton.textContent = 'Start Game'; // Reset button text

            // Set initial player position to the center of the container
            x = (GAME_WIDTH - player.offsetWidth) / 2;
            y = (GAME_HEIGHT - player.offsetHeight) / 2;
            isSquished = false;
            player.style.height = '50px'; // Ensure player is not squished on restart

            // Reset obstacle
            obstacleX = BORDER_WIDTH; // Initial horizontal position, starts on the left border
            obstacleSpeed = 2; // Reset to initial speed
            obstacleDirection = 1; // Start moving right

            // Reset rectangle obstacle
            rectObstacleY = BORDER_WIDTH; // Positioned from the top border
            rectObstacleX = GAME_WIDTH - obstacleRectElement.offsetWidth - BORDER_WIDTH; // Start on the right border
            rectObstacleDirection = -1; // Start moving left

            // Reset and start score
            score = 0;
            scoreDisplay.textContent = `Score: ${score}`;
            clearInterval(scoreInterval); // Ensure no previous interval is running
            scoreInterval = setInterval(() => {
                score++;
                scoreDisplay.textContent = `Score: ${score}`;
                obstacleSpeed += 0.1; // Increase triangle speed every second
            }, 2000); // Update score every 2 seconds

            gameLoop();
        });

        // --- Scaling Logic ---
        function resizeGame() {
            const containerRect = container.getBoundingClientRect();
            // Calculate the best scale to fit the game within the container
            const scale = Math.min(
                containerRect.width / GAME_WIDTH,
                containerRect.height / GAME_HEIGHT
            );
            // Apply the scale to the viewport
            gameViewport.style.transform = `translate(-50%, -50%) scale(${scale})`;
        }

        // Use ResizeObserver to automatically run resizeGame when the container size changes.
        const resizeObserver = new ResizeObserver(() => {
            resizeGame();
        });
        resizeObserver.observe(container);
        // Call it once on load to set the initial size correctly
        resizeGame();

        // --- Fullscreen API ---
        function toggleFullScreen() {
            const doc = window.document;
            const gameEl = container;

            const requestFullScreen = gameEl.requestFullscreen || gameEl.mozRequestFullScreen || gameEl.webkitRequestFullscreen || gameEl.msRequestFullscreen;
            const cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

            if (!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
                requestFullScreen.call(gameEl);
            } else {
                cancelFullScreen.call(doc);
            }
        }

        // --- Fullscreen Button Logic ---
        const fullscreenAPISupported = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;

        if (isIOS) {
            fullscreenBtn.addEventListener('click', () => {
                document.body.classList.toggle('standalone-mode');
                setTimeout(resizeGame, 0);
            });
        } else if (fullscreenAPISupported) {
            fullscreenBtn.addEventListener('click', toggleFullScreen);
        } else {
            fullscreenBtn.style.display = 'none';
        }

        // --- Mobile Control Setup ---
        function setupControlButton(button, key) {
            const press = (e) => {
                e.preventDefault();
                keysPressed[key] = true;
            };
            const release = (e) => {
                e.preventDefault();
                keysPressed[key] = false;
            };

            button.addEventListener('mousedown', press);
            button.addEventListener('mouseup', release);
            button.addEventListener('mouseleave', release); // Handle mouse leaving button while pressed
            button.addEventListener('touchstart', press, { passive: false }); // passive:false allows preventDefault
            button.addEventListener('touchend', release);
        }

        if (isTouchDevice) {
            setupControlButton(btnLeft, 'arrowleft');
            setupControlButton(btnRight, 'arrowright');
            setupControlButton(btnUp, 'arrowup');
            setupControlButton(btnDown, 'arrowdown');
        }
    </script>
</body>

</html>